const { ApiPromise, WsProvider, Keyring, ApiRx } = require("@polkadot/api")
const signer = require('./signer')
const provider = new WsProvider('ws://127.0.0.1:9944')
const { randomAsU8a } = require('@polkadot/util-crypto') // make sure version matches api version
const fs = require('fs')
const types = JSON.parse(fs.readFileSync('src/types.json').toString())

const colors = require('colors/safe');
const NAME = __filename.split('/').pop().split('.')[0].toUpperCase()
function LOG (...msgs) {
  msgs = [`[${NAME}] `, ...msgs].map(msg => colors.blue(msg))
  console.log(...msgs)
}

module.exports = datdotChain()

async function datdotChain () {
  const API = await ApiPromise.create({ provider,types })
  const chainAPI = {
    makeAccount,
    registerHoster,
    publishData
  }
  return chainAPI

  listenToEvents()

  function makeAccount (opts) {
    const {chainAPI, serviceAPI, cb} = opts
    const keyring = new Keyring({ type: 'sr25519' })
    // const account = keyring.addFromSeed(randomAsU8a(32))
    const ALICE = keyring.addFromUri('//Alice')
    const CHARLIE = keyring.addFromUri('//Charlie')
    const FERDIE = keyring.addFromUri('//Ferdie')
    const EVE = keyring.addFromUri('//Eve')
    const DAVE = keyring.addFromUri('//Dave')
    LOG(`ALICE: ${ALICE.address}`)
    LOG(`CHARLIE: ${CHARLIE.address}`)
    LOG(`FERDIE: ${FERDIE.address}`)
    LOG(`EVE: ${EVE.address}`)
    LOG(`DAVE: ${DAVE.address})`)
    const accounts = [ALICE, CHARLIE, FERDIE, EVE, DAVE]
    cb(chainAPI, serviceAPI, accounts)
  }

  async function registerHoster (opts) {
    const {accounts, handleRegisterHoster} = opts
    const registerSeeder = API.tx.datVerify.registerSeeder()
    accounts.forEach(async account => {
      await registerSeeder.signAndSend(account, ({ events = [], status }) => {
        LOG(`Registering user: ${account.address} `, status.type)
        if (status.isFinalized) handleRegisterHoster(account.address, events)
      })
    })
  }

  async function publishData (opts) {
    const {registerPayload, account, handlePublishing} = opts
    const registerData = API.tx.datVerify.registerData(registerPayload)
    await registerData.signAndSend(account, async ({ events = [], status }) => {
      LOG(`Publishing data: ${account.address} `, status.type)
      if (status.isFinalized) handlePublishing(`${account.address}`, events)
    })
  }

  async function listenToEvents () {
    API.query.system.events((events) => {
      events.forEach(async (record) => {
        const event = record.event
        if (event.method === 'SomethingStored') {
            LOG(`DATA FROM EVENT: ${event.data.toString()}`)
            return(event.data)
        }
        if (event.method === 'NewPin') {
            LOG(`DATA FROM EVENT: ${event.data.toString()}`)
            return(event.data)
        }
      })
    })
  }
//
//   function requestHosting (opts, signature) {
//     const accountId = signer.verify(signature, opts)
//     if (!accountId) throw new Error('invalid signature')
//     const registerData = api.tx.datVerify.registerData(archiveArr)
//     await registerData.signAndSend(accountId, async ({ events = [], status }) => {
//       // console.log(`Registering data: `, status.type)
//       if (status.isFinalized) {
//         // events.forEach(({ phase, event: { data, method, section } }) => {
//         //   console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//         // });
//     })
//   }
//
//   function offerEncoding (accountId, handleEncoding) {
//     const registerSeeder = api.tx.datVerify.registerSeeder()
//     await registerSeeder.signAndSend(accountId, ({ events = [], status }) => {
//       console.log(`Registering user: `, status.type)
//       if (status.isFinalized) {
//         events.forEach(({ phase, event: { data, method, section } }) => {
//           console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//         });
//       }
//     })
//   }
//   function onHosting () {
//     api.query.system.events((events) => {
//       events.forEach((record) => {
//         const event = record.event
//         if (event.method === 'SomethingStored') {
//             console.log(`${event.data.toString()}`)
//             return(event.data)
//         }
//       })
//     })
//   }
//   function offHosting () {}
//   function commit (event, merkleRootE) {}
}
