const { ApiPromise, WsProvider, Keyring, ApiRx } = require("@polkadot/api")
const signer = require('./signer')
const provider = new WsProvider('ws://127.0.0.1:9944')
const { randomAsU8a } = require('@polkadot/util-crypto') // make sure version matches api version
const fs = require('fs')
const crypto = require('hypercore-crypto')
const types = JSON.parse(fs.readFileSync('src/types.json').toString())

const colors = require('colors/safe');
const NAME = __filename.split('/').pop().split('.')[0].toUpperCase()
function LOG (...msgs) {
  msgs = [`[${NAME}] `, ...msgs].map(msg => colors.blue(msg))
  console.log(...msgs)
}

module.exports = datdotChain()

async function datdotChain () {
  const API = await ApiPromise.create({ provider,types })
  const chainAPI = {
    makeAccount,
    registerHoster,
    publishData,
    getChallenges,
    respondToChallenges,
    listenToEvents
  }
  return chainAPI

  function makeAccount (opts) {
    const {chainAPI, serviceAPI, cb} = opts
    const keyring = new Keyring({ type: 'sr25519' })
    // const account = keyring.addFromSeed(randomAsU8a(32))
    const ALICE = keyring.addFromUri('//Alice')
    const CHARLIE = keyring.addFromUri('//Charlie')
    const FERDIE = keyring.addFromUri('//Ferdie')
    const EVE = keyring.addFromUri('//Eve')
    const DAVE = keyring.addFromUri('//Dave')
    LOG(`ALICE: ${ALICE.address}`)
    LOG(`CHARLIE: ${CHARLIE.address}`)
    LOG(`FERDIE: ${FERDIE.address}`)
    LOG(`EVE: ${EVE.address}`)
    LOG(`DAVE: ${DAVE.address})`)
    const accounts = [ALICE, CHARLIE, FERDIE, EVE, DAVE]
    cb(chainAPI, serviceAPI, accounts)
  }

// REGISTER HOSTER
  async function registerHoster (opts) {
    const {accounts, handleRegisterHoster} = opts
    accounts.forEach(async account => {
      const register = API.tx.datVerify.registerSeeder()
      await register.signAndSend(account, ({ events = [], status }) => {
        LOG(`Registering user: ${account.address} `, status.type)
        if (status.isFinalized) handleRegisterHoster(account.address, events)
      })
    })
  }

// PUBLISH DATA
  async function publishData (opts) {
    const {registerPayload, account, handlePublishing} = opts
    const registerData = API.tx.datVerify.registerData(registerPayload)
    await registerData.signAndSend(account, async ({ events = [], status }) => {
      LOG(`Publishing data: ${account.address} `, status.type)
      if (status.isFinalized) handlePublishing(`${account.address}`, events)
    })
  }

// GET CHALLENGES
async function getChallenges (opts) {
  const {users, respondToChallenges} = opts
  const challenges = await API.query.datVerify.challengeMap()
  const respondingChallenges = []
  for (const userIndex in users) {
    const user = users[userIndex]
    const userChallengeTuple = await API.query.datVerify.selectedUserIndex(user.address)
    if (userChallengeTuple[1].eq(0)) continue // if user has no challenges - skip them
    const userChallengeIndex = userChallengeTuple[0] // this is the user's ID in the challenge context
    const userChallengePromises = await Promise.all(
      challenges.map(async (challengeIndex, index) => {
        if (challenges[1][index]) {
          if (challenges[1][index].eq(userChallengeIndex)) {
            const challengeDetailsTuple = await API.query.datVerify.selectedChallenges(challengeIndex)
            const challengeDetails = challengeDetailsTuple.toJSON()
            challengeDetails[3] = challengeIndex
            return challengeDetails.flat()
          }
        }
    }
    ))
    const userChallengeUnfiltered = await Promise.all(userChallengePromises)
    const userChallenges = userChallengeUnfiltered.filter((e) => {
      return e
    })
    if (userChallenges.length) {
      for (const i in userChallenges) {
        const challengeDetails = userChallenges[i]
        const challengeObject = { }
        challengeObject.user = user
        challengeObject.pubkey = challengeDetails[0]
        challengeObject.index = challengeDetails[1]
        challengeObject.deadline = challengeDetails[2]
        challengeObject.challengeIndex = challengeDetails[3]
        respondingChallenges.push(challengeObject)
      }
    }
  }
  respondToChallenges(respondingChallenges)
}

// RESPOND TO CHALLENGE

async function respondToChallenges (opts) {
  const {challengeObjects, feeds} = opts
    for (const i in challengeObjects) {
      const challenge = challengeObjects[i]
      const user = challenge.user
      const pubkey = challenge.pubkey.slice(2)
      LOG('pubkey', pubkey.toString())
      const deadline = challenge.deadline
      const challengeIndex = challenge.challengeIndex
      const feed = feeds[pubkey]
      let index = {}
      let err = {}
      let merkleRoot = {}
      feed.seek(challenge.index, async function (e, offsetIndex, offset) {
        index = offsetIndex
        err = e
        feed.rootHashes(index, async function (e, roots) {
          err = e
          merkleRoot = crypto.tree(roots)
          feed.get(index, async function (e, chunk) {
            err = e
            LOG('CHUNK: ' + chunk.toString('hex'))
            feed.proof(index, async function (e, nodes) {
              err = e
              if (nodes && chunk) {
                LOG(nodes)
                const challengeResponseExt = API.tx.datVerify.submitProof(challengeIndex, nodes, merkleRoot, chunk.toString('hex'))
                LOG(API.signer)
                await promiseRerun(challengeResponseExt.signAndSend(user, ({ events = [], status }) => {
                  if (status.isFinalized) {
                    events.forEach(({ phase, event: { data, method, section } }) => {
                      LOG('\t', phase.toString(), `: ${section}.${method}`, data.toString())
                    })
                  }
                })).catch(console.log)
              }
            })
          })
        })
        if (e) {
          console.log('Failed to complete challenge for chunk: ' + index.toString() + '/' + feed.length)
          console.log('Reason: ')
          console.log(err)
        }
      })
    }
  }

// LISTEN TO EVENTS

async function listenToEvents (getChallenges) {
  const unsub = API.query.system.events((events) => {
    events.forEach(async (record) => {
      const event = record.event
      if (event.method === 'Challenge') {
          LOG('NEW CHALLENGE', event.data.toString())
          const account = event.data[0]
          getChallenges(account)
      }
      if (event.method === 'ChallengeFailed') {
          LOG('CHALLENGE FAILED', event.data.toString())
      }
    })
  })
}

// HELPERS

async function promiseRerun (promise) {
  var success = true
  do {
    return promise.catch((e) => {
      success = false
      console.error(e)
      console.log('Retrying!')
    })
  } while (!success)
}


//
//   function requestHosting (opts, signature) {
//     const accountId = signer.verify(signature, opts)
//     if (!accountId) throw new Error('invalid signature')
//     const registerData = API.tx.datVerify.registerData(archiveArr)
//     await registerData.signAndSend(accountId, async ({ events = [], status }) => {
//       // console.log(`Registering data: `, status.type)
//       if (status.isFinalized) {
//         // events.forEach(({ phase, event: { data, method, section } }) => {
//         //   console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//         // });
//     })
//   }
//
//   function offerEncoding (accountId, handleEncoding) {
//     const registerSeeder = API.tx.datVerify.registerSeeder()
//     await registerSeeder.signAndSend(accountId, ({ events = [], status }) => {
//       console.log(`Registering user: `, status.type)
//       if (status.isFinalized) {
//         events.forEach(({ phase, event: { data, method, section } }) => {
//           console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//         });
//       }
//     })
//   }
//   function onHosting () {
//     API.query.system.events((events) => {
//       events.forEach((record) => {
//         const event = record.event
//         if (event.method === 'SomethingStored') {
//             console.log(`${event.data.toString()}`)
//             return(event.data)
//         }
//       })
//     })
//   }
//   function offHosting () {}
//   function commit (event, merkleRootE) {}
}
