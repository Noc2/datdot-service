const { ApiPromise, WsProvider, Keyring, ApiRx } = require("@polkadot/api")
const signer = require('./signer')
const provider = new WsProvider('ws://127.0.0.1:9944')
const { randomAsU8a } = require('@polkadot/util-crypto') // make sure version matches api version
const fs = require('fs')
const crypto = require('hypercore-crypto')
const types = JSON.parse(fs.readFileSync('src/types.json').toString())

const colors = require('colors/safe');
const NAME = __filename.split('/').pop().split('.')[0].toUpperCase()
function LOG (...msgs) {
  msgs = [`[${NAME}] `, ...msgs].map(msg => colors.blue(msg))
  console.log(...msgs)
}

module.exports = datdotChain()

async function datdotChain () {
  const API = await ApiPromise.create({ provider,types })
  const chainAPI = {
    makeAccount,
    registerHoster,
    publishData,
    getChallenges,
    respondToChallenges,
    listenToEvents
  }
  return chainAPI

  function makeAccount (opts) {
    const {chainAPI, serviceAPI, cb} = opts
    const keyring = new Keyring({ type: 'sr25519' })
    // const account = keyring.addFromSeed(randomAsU8a(32))
    const ALICE = keyring.addFromUri('//Alice')
    const CHARLIE = keyring.addFromUri('//Charlie')
    const FERDIE = keyring.addFromUri('//Ferdie')
    const EVE = keyring.addFromUri('//Eve')
    const DAVE = keyring.addFromUri('//Dave')
    LOG(`ALICE: ${ALICE.address}`)
    LOG(`CHARLIE: ${CHARLIE.address}`)
    LOG(`FERDIE: ${FERDIE.address}`)
    LOG(`EVE: ${EVE.address}`)
    LOG(`DAVE: ${DAVE.address})`)
    const accounts = [ALICE, CHARLIE, FERDIE, EVE, DAVE]
    cb(chainAPI, serviceAPI, accounts)
  }

// REGISTER HOSTER
  async function registerHoster (opts) {
    const {accounts, handleRegisterHoster} = opts
    accounts.forEach(async account => {
      const register = API.tx.datVerify.registerSeeder()
      await register.signAndSend(account, ({ events = [], status }) => {
        LOG(`Registering user: ${account.address} `, status.type)
        if (status.isFinalized) handleRegisterHoster(account.address, events)
      })
    })
  }

// PUBLISH DATA
  async function publishData (opts) {
    const {registerPayload, account, handlePublishing} = opts
    const registerData = API.tx.datVerify.registerData(registerPayload)
    await registerData.signAndSend(account, async ({ events = [], status }) => {
      LOG(`Publishing data: ${account.address} `, status.type)
      if (status.isFinalized) handlePublishing(`${account.address}`, events)
    })
  }

// GET CHALLENGES
async function getChallenges (opts) {
  const {users, respondToChallenges} = opts
  const allChallenges = await API.query.datVerify.challengeMap()
  for (var i = 0; i < users.length; i++) {
    getChallenge(users[i], allChallenges, respondingChallenges = [])
  }
  respondToChallenges(respondingChallenges)
}

async function getChallenge (user, allChallenges, respondingChallenges) {
  const userChallengeTuple = await API.query.datVerify.selectedUserIndex(user.address)
  if (userChallengeTuple[1].length) {
    const userChallengeID = userChallengeTuple[0] // this is the user's ID in the challenge context
    const userChallengePromises = await Promise.all(
      allChallenges.map(async (challengeID, j) => {
        const challengesIDs = allChallenges[1]
        if (challengesIDs[j] && challengesIDs[j] === userChallengeID) {
          const challengeTuple = await API.query.datVerify.selectedChallenges(challengeID)
          const challengeDetails = challengeTuple.toJSON()
          challengeDetails[3] = challengeID
          return challengeDetails.flat()
        }
      }
    ))
    const userChallengeUnfiltered = await Promise.all(userChallengePromises)
    const userChallenges = userChallengeUnfiltered.filter((e) => {return e})
    pushChallengeObj(userChallenges)
  }
}

function pushChallengeObj (userChallenges) {
  if (userChallenges.length) {
    for (var j = 0; j < userChallenges.length; j ++) {
      const challengeDetails = userChallenges[j]
      const challengeObj = {}
      challengeObj.user = user
      challengeObj.pubkey = challengeDetails[0]
      challengeObj.index = challengeDetails[1]
      challengeObj.deadline = challengeDetails[2]
      challengeObj.challengeIndex = challengeDetails[3]
      respondingChallenges.push(challenge)
    }
  }
}

// async function getChallenges (opts) {
//   const {address, respondToChallenges} = opts
//   const respondingChallenges = []
//   const challengeIndeces = await getUserChallengeIndeces(address)
//   challengeIndeces.forEach(async challengeIndex => {
//     const challenge = await API.query.datVerify.selectedChallenges(challengeIndex)
//     const challengeObject = { }
//     challengeObject.user = address
//     challengeObject.pubkey = challenge[0]
//     challengeObject.index = challenge[1]
//     challengeObject.deadline = challenge[2]
//     challengeObject.challengeIndex = challenge[3]
//     respondingChallenges.push(challengeObject)
//     LOG('CHALLENGE OBJ', challenge.toJSON())
//     if (respondingChallenges.length === challengeIndeces.length) {
//       respondToChallenges(respondingChallenges)
//     }
//   })
//  }
//
//  async function getUserChallengeIndeces (address) {
//    const selectedUserIndex = await addressToSelectedUserIndex(address)
//    const allChallenges = await API.query.datVerify.challengeMap()
//    LOG('All challenges', allChallenges.toString()) //logs [[idsOfChallenges], [idsOfUsers]]
//    const idsOfUsers = allChallenges[1]
//    const userChallengeIndeces = []
//    for (var i = 0; i < idsOfUsers.length; i++) {
//      if (idsOfUsers[i].toString() === Number(selectedUserIndex).toString()) {
//        userChallengeIndeces.push(i)
//      }
//    }
//    LOG(`Indexes of all the challenges for user ${address}:`, userChallengeIndeces)
//    return userChallengeIndeces
//  }
//
//  async function addressToSelectedUserIndex(address){
//      const challengedUser = await API.query.datVerify.selectedUserIndex(address)
//      const userIndex = challengedUser[0]
//      const challengeCount = challengedUser[1]
//      LOG("User: "+address+", at index: "+userIndex+" has "+challengeCount+" challenges!")
//      return userIndex
//  }

// RESPOND TO CHALLENGE

async function respondToChallenges (opts) {
  const {challengeObjects, feeds} = opts
    for (const i in challengeObjects) {
      const challenge = challengeObjects[i]
      const user = challenge.user
      const pubkey = challenge.pubkey.slice(2)
      LOG('pubkey', pubkey.toString())
      const deadline = challenge.deadline
      const challengeIndex = challenge.challengeIndex
      const feed = feeds[pubkey]
      let index = {}
      let err = {}
      let merkleRoot = {}
      feed.seek(challenge.index, async function (e, offsetIndex, offset) {
        index = offsetIndex
        err = e
        feed.rootHashes(index, async function (e, roots) {
          err = e
          merkleRoot = crypto.tree(roots)
          feed.get(index, async function (e, chunk) {
            err = e
            LOG('CHUNK: ' + chunk.toString('hex'))
            feed.proof(index, async function (e, nodes) {
              err = e
              if (nodes && chunk) {
                LOG(nodes)
                const challengeResponseExt = API.tx.datVerify.submitProof(challengeIndex, nodes, merkleRoot, chunk.toString('hex'))
                LOG(API.signer)
                await promiseRerun(challengeResponseExt.signAndSend(user, ({ events = [], status }) => {
                  if (status.isFinalized) {
                    events.forEach(({ phase, event: { data, method, section } }) => {
                      LOG('\t', phase.toString(), `: ${section}.${method}`, data.toString())
                    })
                  }
                })).catch(console.log)
              }
            })
          })
        })
        if (e) {
          console.log('Failed to complete challenge for chunk: ' + index.toString() + '/' + feed.length)
          console.log('Reason: ')
          console.log(err)
        }
      })
    }
  }

// LISTEN TO EVENTS

async function listenToEvents (getChallenges) {
  const unsub = API.query.system.events((events) => {
    events.forEach(async (record) => {
      const event = record.event
      if (event.method === 'Challenge') {
          LOG('NEW CHALLENGE', event.data.toString())
          const account = event.data[0]
          getChallenges(account)
      }
      if (event.method === 'ChallengeFailed') {
          LOG('CHALLENGE FAILED', event.data.toString())
      }
    })
  })
}

// HELPERS

async function promiseRerun (promise) {
  var success = true
  do {
    return promise.catch((e) => {
      success = false
      console.error(e)
      console.log('Retrying!')
    })
  } while (!success)
}


//
//   function requestHosting (opts, signature) {
//     const accountId = signer.verify(signature, opts)
//     if (!accountId) throw new Error('invalid signature')
//     const registerData = API.tx.datVerify.registerData(archiveArr)
//     await registerData.signAndSend(accountId, async ({ events = [], status }) => {
//       // console.log(`Registering data: `, status.type)
//       if (status.isFinalized) {
//         // events.forEach(({ phase, event: { data, method, section } }) => {
//         //   console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//         // });
//     })
//   }
//
//   function offerEncoding (accountId, handleEncoding) {
//     const registerSeeder = API.tx.datVerify.registerSeeder()
//     await registerSeeder.signAndSend(accountId, ({ events = [], status }) => {
//       console.log(`Registering user: `, status.type)
//       if (status.isFinalized) {
//         events.forEach(({ phase, event: { data, method, section } }) => {
//           console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//         });
//       }
//     })
//   }
//   function onHosting () {
//     API.query.system.events((events) => {
//       events.forEach((record) => {
//         const event = record.event
//         if (event.method === 'SomethingStored') {
//             console.log(`${event.data.toString()}`)
//             return(event.data)
//         }
//       })
//     })
//   }
//   function offHosting () {}
//   function commit (event, merkleRootE) {}
}
