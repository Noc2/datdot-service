const { ApiPromise, WsProvider, Keyring, ApiRx } = require("@polkadot/api")
const signer = require('./signer')
const provider = new WsProvider('ws://127.0.0.1:9944')
const { randomAsU8a } = require('@polkadot/util-crypto') // make sure version matches api version
const fs = require('fs')
const crypto = require('hypercore-crypto')
const path = require('path')
const filename = path.join(__dirname, '../../../src/types.json')
const types = JSON.parse(fs.readFileSync(filename).toString())

const colors = require('colors/safe');
const NAME = __filename.split('/').pop().split('.')[0].toUpperCase()
function LOG (...msgs) {
  msgs = [`[${NAME}] `, ...msgs].map(msg => colors.blue(msg))
  console.log(...msgs)
}

module.exports = datdotChain()

async function datdotChain () {
  const API = await ApiPromise.create({ provider,types })
  const chainAPI = {
    makeAccount,
    registerHoster,
    publishData,
    getChallenges,
    respondToChallenges,
    listenToEvents
  }
  return chainAPI

  function makeAccount (opts) {
    const {chainAPI, serviceAPI, cb} = opts
    const keyring = new Keyring({ type: 'sr25519' })
    // const account = keyring.addFromSeed(randomAsU8a(32))
    const ALICE = keyring.addFromUri('//Alice')
    const CHARLIE = keyring.addFromUri('//Charlie')
    const FERDIE = keyring.addFromUri('//Ferdie')
    const EVE = keyring.addFromUri('//Eve')
    const DAVE = keyring.addFromUri('//Dave')
    LOG(`ALICE: ${ALICE.address}`)
    LOG(`CHARLIE: ${CHARLIE.address}`)
    LOG(`FERDIE: ${FERDIE.address}`)
    LOG(`EVE: ${EVE.address}`)
    LOG(`DAVE: ${DAVE.address})`)
    const accounts = [ALICE, CHARLIE, FERDIE, EVE, DAVE]
    cb(chainAPI, serviceAPI, accounts)
  }

// REGISTER HOSTER
  async function registerHoster (opts) {
    const {accounts, handleRegisterHoster} = opts
    accounts.forEach(async account => {
      const register = API.tx.datVerify.registerSeeder()
      await register.signAndSend(account, ({ events = [], status }) => {
        LOG(`Registering user: ${account.address} `, status.type)
        if (status.isInBlock) handleRegisterHoster(account.address, events)
      })
    })
  }

// PUBLISH DATA
  async function publishData (opts) {
    const {registerPayload, account, handlePublishing} = opts
    const registerData = API.tx.datVerify.registerData(registerPayload)
    await registerData.signAndSend(account, async ({ events = [], status }) => {
      LOG(`Publishing data: ${account.address} `, status.type)
      if (status.isInBlock) handlePublishing(`${account.address}`, events)
    })
  }

// GET CHALLENGES
async function getChallenges (opts) {
  const {users, respondToChallenges} = opts
  const allChallenges = await API.query.datVerify.challengeMap()
  for (var i = 0; i < users.length; i++) {
    getChallenge(users[i], allChallenges, respondingChallenges = [])
  }
  respondToChallenges(respondingChallenges)
}

async function getChallenge (user, allChallenges, respondingChallenges) {
  const userChallengeTuple = await API.query.datVerify.selectedUserIndex(user.address)
  if (userChallengeTuple[1].length) {
    const userChallengeID = userChallengeTuple[0] // this is the user's ID in the challenge context
    const userChallengePromises = await Promise.all(
      allChallenges.map(async (challengeID, j) => {
        const challengesIDs = allChallenges[1]
        if (challengesIDs[j] && challengesIDs[j] === userChallengeID) {
          const challengeTuple = await API.query.datVerify.selectedChallenges(challengeID)
          const challengeDetails = challengeTuple.toJSON()
          challengeDetails[3] = challengeID
          return challengeDetails.flat()
        }
      }
    ))
    const userChallengeUnfiltered = await Promise.all(userChallengePromises)
    const userChallenges = userChallengeUnfiltered.filter((e) => {return e})
    pushChallengeObj(userChallenges)
  }
}

function pushChallengeObj (userChallenges) {
  if (userChallenges.length) {
    for (var j = 0; j < userChallenges.length; j ++) {
      const challengeDetails = userChallenges[j]
      const challengeObj = {}
      challengeObj.user = user
      challengeObj.pubkey = challengeDetails[0]
      challengeObj.index = challengeDetails[1]
      challengeObj.deadline = challengeDetails[2]
      challengeObj.challengeIndex = challengeDetails[3]
      respondingChallenges.push(challenge)
    }
  }
}

// RESPOND TO CHALLENGE

async function respondToChallenges (opts) {
  const {challengeObjects, feeds} = opts
    for (const i in challengeObjects) {
      const challenge = challengeObjects[i]
      const user = challenge.user
      const pubkey = challenge.pubkey.slice(2)
      LOG('pubkey', pubkey.toString())
      const deadline = challenge.deadline
      const challengeIndex = challenge.challengeIndex
      const feed = feeds[pubkey]
      let index = {}
      let err = {}
      let merkleRoot = {}
      feed.seek(challenge.index, async function (e, offsetIndex, offset) {
        index = offsetIndex
        err = e
        feed.rootHashes(index, async function (e, roots) {
          err = e
          merkleRoot = crypto.tree(roots)
          feed.get(index, async function (e, chunk) {
            err = e
            LOG('CHUNK: ' + chunk.toString('hex'))
            feed.proof(index, async function (e, nodes) {
              err = e
              if (nodes && chunk) {
                LOG(nodes)
                const challengeResponseExt = API.tx.datVerify.submitProof(challengeIndex, nodes, merkleRoot, chunk.toString('hex'))
                LOG(API.signer)
                await promiseRerun(challengeResponseExt.signAndSend(user, ({ events = [], status }) => {
                  if (status.isInBlock) {
                    events.forEach(({ phase, event: { data, method, section } }) => {
                      LOG('\t', phase.toString(), `: ${section}.${method}`, data.toString())
                    })
                  }
                })).catch(console.log)
              }
            })
          })
        })
        if (e) {
          console.log('Failed to complete challenge for chunk: ' + index.toString() + '/' + feed.length)
          console.log('Reason: ')
          console.log(err)
        }
      })
    }
  }

// LISTEN TO EVENTS

async function listenToEvents (getChallenges) {
  const unsub = API.query.system.events((events) => {
    events.forEach(async (record) => {
      const event = record.event
      if (event.method === 'Challenge') {
          LOG('NEW CHALLENGE', event.data.toString())
          const account = event.data[0]
          getChallenges(account)
      }
      if (event.method === 'ChallengeFailed') {
          LOG('CHALLENGE FAILED', event.data.toString())
      }
    })
  })
}

// HELPERS

async function promiseRerun (promise) {
  var success = true
  do {
    return promise.catch((e) => {
      success = false
      console.error(e)
      console.log('Retrying!')
    })
  } while (!success)
}

}
