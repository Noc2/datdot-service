"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.info = info;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("../util");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function createDerived(api, [[hasBabe, epochDuration, sessionsPerEra], {
  activeEra,
  activeEraStart,
  currentEra,
  currentIndex,
  validatorCount
}, [currentSlot, epochIndex, epochOrGenesisStartSlot, activeEraStartSessionIndex]]) {
  const epochStartSlot = epochIndex.mul(epochDuration).add(epochOrGenesisStartSlot);
  const sessionProgress = currentSlot.sub(epochStartSlot);
  const eraProgress = currentIndex.sub(activeEraStartSessionIndex).mul(epochDuration).add(sessionProgress);
  return {
    activeEra,
    activeEraStart,
    currentEra,
    currentIndex,
    eraLength: (0, _types.createType)(api.registry, 'BlockNumber', sessionsPerEra.mul(epochDuration)),
    eraProgress: (0, _types.createType)(api.registry, 'BlockNumber', eraProgress),
    isEpoch: hasBabe,
    sessionLength: epochDuration,
    sessionsPerEra,
    sessionProgress: (0, _types.createType)(api.registry, 'BlockNumber', sessionProgress),
    validatorCount
  };
}

function queryAura(api) {
  return api.derive.session.indexes().pipe((0, _operators.map)(indexes => {
    var _api$consts$staking;

    return createDerived(api, [[false, (0, _types.createType)(api.registry, 'u64', 1), ((_api$consts$staking = api.consts.staking) === null || _api$consts$staking === void 0 ? void 0 : _api$consts$staking.sessionsPerEra) || (0, _types.createType)(api.registry, 'SessionIndex', 1)], indexes, [(0, _types.createType)(api.registry, 'u64', 1), (0, _types.createType)(api.registry, 'u64', 1), (0, _types.createType)(api.registry, 'u64', 1), (0, _types.createType)(api.registry, 'SessionIndex', 1)]]);
  }));
}

function queryBabe(api) {
  return api.derive.session.indexes().pipe((0, _operators.switchMap)(indexes => (0, _rxjs.combineLatest)([(0, _rxjs.of)(indexes), api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, [api.query.staking.erasStartSessionIndex, indexes.activeEra]])])), (0, _operators.map)(([indexes, [currentSlot, epochIndex, genesisSlot, optStartIndex]]) => [indexes, [currentSlot, epochIndex, genesisSlot, optStartIndex.unwrapOr((0, _types.createType)(api.registry, 'SessionIndex', 1))]]));
}

function queryBabeNoHistory(api) {
  return (0, _rxjs.combineLatest)([api.derive.session.indexes(), api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, api.query.staking.currentEraStartSessionIndex])]);
}
/**
 * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras
 */


function info(api) {
  return (0, _util.memo)(() => api.consts.babe ? (api.query.staking.erasStartSessionIndex ? queryBabe(api) // 2.x with Babe
  : queryBabeNoHistory(api)).pipe((0, _operators.map)(([indexes, slots]) => createDerived(api, [[true, api.consts.babe.epochDuration, api.consts.staking.sessionsPerEra], indexes, slots]))) : queryAura(api));
}