"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.query = query;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("../util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function unwrapSessionIds(stashId, queuedKeys, nextKeys) {
  // for 2.x we have a Vec<(ValidatorId,Keys)> of the keys
  if (Array.isArray(queuedKeys)) {
    const sessionIds = (queuedKeys.find(([currentId]) => currentId.eq(stashId)) || [undefined, []])[1];
    const nextSessionIds = nextKeys.unwrapOr([]);
    return {
      nextSessionIds,
      sessionIds
    };
  } // substrate 1.x


  const nextSessionIds = queuedKeys.isSome ? [queuedKeys.unwrap()] : [];
  return {
    nextSessionIds,
    sessionIds: nextSessionIds
  };
}

function parseResult(api, {
  accountId,
  controllerId,
  stashId,
  nextKeyFor,
  queuedKeys,
  stakingLedger,
  nominators,
  rewardDestination,
  stakers,
  validatorPrefs,
  nextKeys
}) {
  const _stakingLedger = stakingLedger.unwrapOr(undefined);

  const _nextKeyFor = nextKeyFor || (0, _types.createType)(api.registry, 'Option<AccountId>', null);

  const _nextKeys = nextKeys || (0, _types.createType)(api.registry, 'Option<Keys>', null);

  return _objectSpread({
    accountId,
    controllerId,
    nominators,
    rewardDestination,
    stakers,
    stakingLedger: _stakingLedger,
    stashId,
    validatorPrefs
  }, unwrapSessionIds(stashId, queuedKeys || _nextKeyFor, _nextKeys));
}

function retrieveInfoV1(api, accountId, stashId, controllerId) {
  return api.queryMulti([[api.query.session.nextKeyFor, controllerId], [api.query.staking.ledger, controllerId], [api.query.staking.nominators, stashId], [api.query.staking.payee, stashId], [api.query.staking.stakers, stashId], [api.query.staking.validators, stashId]]).pipe((0, _operators.map)(([nextKeyFor, stakingLedger, [nominators], rewardDestination, stakers, [validatorPrefs]]) => parseResult(api, {
    accountId,
    controllerId,
    stashId,
    nextKeyFor,
    stakingLedger,
    nominators,
    rewardDestination,
    stakers,
    validatorPrefs
  })));
}

function retrieveInfoV2(api, accountId, stashId, controllerId) {
  return (0, _rxjs.combineLatest)([api.query.session.queuedKeys(), api.queryMulti([[api.query.staking.nominators, stashId], [api.query.staking.payee, stashId], [api.query.staking.stakers, stashId], [api.query.staking.validators, stashId], [api.query.session.nextKeys, [api.consts.session.dedupKeyPrefix, stashId]], [api.query.staking.ledger, controllerId]])]).pipe((0, _operators.map)(([queuedKeys, [_nominators, rewardDestination, stakers, [validatorPrefs], nextKeys, stakingLedger]]) => {
    // if we have staking.storageVersion it indicates the new structure, unwrap as needed
    // FIXME We really want to be pulling all the new (valuable) info along
    const nominators = api.query.staking.storageVersion ? _nominators.isSome ? _nominators.unwrap()[0].targets : [] : _nominators[0];
    return parseResult(api, {
      accountId,
      controllerId,
      stashId,
      queuedKeys,
      stakingLedger,
      nominators,
      rewardDestination,
      stakers,
      validatorPrefs,
      nextKeys
    });
  }));
}

function retrieveV1(api, accountId) {
  // depending on where we come from, this may be a controller or stash
  return (0, _rxjs.combineLatest)([api.query.staking.bonded(accountId), api.query.staking.ledger(accountId)]).pipe((0, _operators.switchMap)(([bonded, stakingLedger]) => stakingLedger.isSome ? retrieveInfoV1(api, accountId, stakingLedger.unwrap().stash, accountId) : bonded.isSome ? retrieveInfoV1(api, accountId, accountId, bonded.unwrap()) : (0, _rxjs.of)({
    accountId: accountId,
    nextSessionIds: [],
    sessionIds: []
  })));
}

function retrieveV2(api, stashId) {
  return api.query.staking.bonded(stashId).pipe((0, _operators.switchMap)(controllerId => controllerId.isSome ? retrieveInfoV2(api, stashId, stashId, controllerId.unwrap()) : (0, _rxjs.of)({
    accountId: stashId,
    nextSessionIds: [],
    sessionIds: []
  })));
}
/**
 * @description From a stash, retrieve the controllerId and fill in all the relevant staking details
 */


function query(api) {
  const retrieve = api.consts.session ? retrieveV2 : retrieveV1;
  return (0, _util.memo)(accountId => retrieve(api, (0, _types.createType)(api.registry, 'AccountId', accountId)));
}