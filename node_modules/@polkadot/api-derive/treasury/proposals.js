"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proposals = proposals;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("../util");

// Copyright 2017-2019 @polkadot/api-derive authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function parseResult(_api, _ref) {
  let {
    allIds,
    allProposals,
    approvalIds,
    councilProposals,
    proposalCount
  } = _ref;
  const approvals = [];
  const proposals = [];
  const councilTreasury = councilProposals.filter((_ref2) => {
    let {
      proposal: {
        methodName,
        sectionName
      }
    } = _ref2;
    return sectionName === 'treasury' && ['approveProposal', 'rejectProposal'].includes(methodName);
  });
  allIds.forEach((id, index) => {
    if (allProposals[index].isSome) {
      const council = councilTreasury.filter((_ref3) => {
        let {
          proposal
        } = _ref3;
        return id.eq(proposal.args[0]);
      }).sort((a, b) => a.proposal.methodName.localeCompare(b.proposal.methodName));
      const isApproval = approvalIds.some(approvalId => approvalId.eq(id));
      const derived = {
        council,
        id,
        proposal: allProposals[index].unwrap()
      };

      if (isApproval) {
        approvals.push(derived);
      } else {
        proposals.push(derived);
      }
    }
  });
  return {
    approvals,
    proposalCount,
    proposals
  };
}

function retrieveProposals(api, proposalCount, approvalIds) {
  const proposalIds = [];
  const count = proposalCount.toNumber();

  for (let index = 0; index < count; index++) {
    const isApproval = approvalIds.some(id => id.eqn(index));

    if (!isApproval) {
      proposalIds.push((0, _types.createType)(api.registry, 'ProposalIndex', index));
    }
  }

  const allIds = [...proposalIds, ...approvalIds];
  return (0, _rxjs.combineLatest)([// We are doing single subscriptions on all these, multi may yield old results
  (0, _rxjs.combineLatest)(allIds.map(id => api.query.treasury.proposals(id))), api.derive.council.proposals()]).pipe((0, _operators.map)((_ref4) => {
    let [allProposals, councilProposals] = _ref4;
    return parseResult(api, {
      allIds,
      allProposals,
      approvalIds,
      councilProposals,
      proposalCount
    });
  }));
}
/**
 * @description Retrieve all active and approved treasury proposals, along with their info
 */


function proposals(api) {
  return (0, _util.memo)(() => api.query.treasury ? (0, _rxjs.combineLatest)([api.query.treasury.proposalCount(), api.query.treasury.approvals()]).pipe((0, _operators.switchMap)((_ref5) => {
    let [proposalCount, approvalIds] = _ref5;
    return retrieveProposals(api, proposalCount, approvalIds);
  })) : (0, _rxjs.of)({
    approvals: [],
    proposalCount: (0, _types.createType)(api.registry, 'ProposalIndex'),
    proposals: []
  }));
}