"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _Extrinsic = require("@polkadot/types/extrinsic/Extrinsic");

var _known = require("@polkadot/types/known");

var _util = require("@polkadot/util");

var _utilCrypto = require("@polkadot/util-crypto");

var _Decorate = _interopRequireDefault(require("./Decorate"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const KEEPALIVE_INTERVAL = 15000;
const l = (0, _util.logger)('api/init');

class Init extends _Decorate.default {
  constructor(options, type, decorateMethod) {
    super(options, type, decorateMethod);
    Object.defineProperty(this, _healthTimer, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _updateSub, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onProviderConnect, {
      writable: true,
      value: async () => {
        this.emit('connected');

        this._isConnected.next(true);

        try {
          const [hasMeta, cryptoReady] = await Promise.all([this.loadMeta(), (0, _utilCrypto.cryptoWaitReady)()]);

          if (hasMeta && !this._isReady && cryptoReady) {
            this._isReady = true;
            this.emit('ready', this);
          }

          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = setInterval(() => {
            this._rpcCore.system.health().toPromise().catch(() => {// ignore
            });
          }, KEEPALIVE_INTERVAL);
        } catch (_error) {
          const error = new Error("FATAL: Unable to initialize the API: ".concat(_error.message));
          l.error(error);
          this.emit('error', error);
        }
      }
    });
    Object.defineProperty(this, _onProviderDisconnect, {
      writable: true,
      value: () => {
        this.emit('disconnected');

        this._isConnected.next(false);

        if ((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]) {
          clearInterval((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]);
          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = null;
        }
      }
    });
    Object.defineProperty(this, _onProviderError, {
      writable: true,
      value: error => {
        this.emit('error', error);
      }
    });

    if (!this.hasSubscriptions) {
      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');
    } // We only register the types (global) if this is not a cloned instance.
    // Do right up-front, so we get in the user types before we are actually
    // doing anything on-chain, this ensures we have the overrides in-place


    if (!options.source && options.types) {
      this.registerTypes(options.types);
    }

    this._rpc = this.decorateRpc(this._rpcCore, this.decorateMethod);
    this._rx.rpc = this.decorateRpc(this._rpcCore, this.rxDecorateMethod);
    this._queryMulti = this.decorateMulti(this.decorateMethod);
    this._rx.queryMulti = this.decorateMulti(this.rxDecorateMethod);
    this._rx.signer = options.signer;

    this._rpcCore.provider.on('disconnected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderDisconnect)[_onProviderDisconnect]);

    this._rpcCore.provider.on('error', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderError)[_onProviderError]);

    this._rpcCore.provider.on('connected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]); // If the provider was instantiated earlier, and has already emitted a
    // 'connected' event, then the `on('connected')` won't fire anymore. To
    // cater for this case, we call manually `this._onProviderConnect`.


    if (this._rpcCore.provider.isConnected()) {
      (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]();
    }
  }

  async loadMeta() {
    var _this$_options$source;

    const genesisHash = await this._rpcCore.chain.getBlockHash(0).toPromise(); // on re-connection to the same chain, we don't want to re-do everything from chain again

    if (this._isReady && !this._options.source && genesisHash.eq(this._genesisHash)) {
      return true;
    }

    if (this._genesisHash) {
      l.warn('Connection to new genesis detected, re-initializing');
    }

    this._genesisHash = genesisHash;

    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {
      (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub].unsubscribe();
    }

    const {
      metadata = {}
    } = this._options; // only load from on-chain if we are not a clone (default path), alternatively
    // just use the values from the source instance provided

    this._runtimeMetadata = ((_this$_options$source = this._options.source) === null || _this$_options$source === void 0 ? void 0 : _this$_options$source._isReady) ? await this.metaFromSource(this._options.source) : await this.metaFromChain(metadata);
    return this.initFromMeta(this._runtimeMetadata);
  } // eslint-disable-next-line @typescript-eslint/require-await


  async metaFromSource(source) {
    this._extrinsicType = source.extrinsicVersion;
    this._runtimeVersion = source.runtimeVersion;
    this._genesisHash = source.genesisHash;
    this.registry.setChainProperties(source.registry.getChainProperties());
    const methods = []; // manually build a list of all available methods in this RPC, we are
    // going to filter on it to align the cloned RPC without making a call

    Object.keys(source.rpc).forEach(section => {
      Object.keys(source.rpc[section]).forEach(method => {
        methods.push("".concat(section, "_").concat(method));
      });
    });
    this.filterRpcMethods(methods);
    return source.runtimeMetadata;
  } // subscribe to metadata updates, inject the types on changes


  subscribeUpdates() {
    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {
      return;
    }

    (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _operators.switchMap)(version => (0, _rxjs.combineLatest)((0, _rxjs.of)(version), this._rpcCore.state.getMetadata())), (0, _operators.map)(([version, metadata]) => {
      var _this$_runtimeVersion;

      if ((_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specVersion.eq(version.specVersion)) {
        return false;
      }

      l.log("Runtime version updated to ".concat(version.specVersion));
      this._runtimeMetadata = metadata;
      this._runtimeVersion = version;
      this.registerTypes((0, _known.getSpecTypes)(this._runtimeChain, version));
      this.injectMetadata(metadata, false);
      return true;
    })).subscribe();
  }

  async metaFromChain(optMetadata) {
    const {
      typesChain,
      typesSpec
    } = this._options;
    const [runtimeVersion, chain, chainProps] = await Promise.all([this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise()]); // set our chain version & genesisHash as returned

    this._runtimeChain = chain;
    this._runtimeVersion = runtimeVersion; // do the setup for the specific chain

    this.registry.setChainProperties(chainProps);
    this.registerTypes((0, _known.getSpecTypes)(chain, runtimeVersion));
    this.registerTypes((0, _known.getUserTypes)(chain, runtimeVersion, typesChain, typesSpec));
    this.subscribeUpdates(); // filter the RPC methods (this does an rpc-methods call)

    await this.filterRpc(); // retrieve metadata, either from chain  or as pass-in via options

    const metadataKey = "".concat(this._genesisHash, "-").concat(runtimeVersion.specVersion);
    const metadata = metadataKey in optMetadata ? new _types.Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise(); // get unique types & validate

    metadata.getUniqTypes(false);
    return metadata;
  }

  async initFromMeta(metadata) {
    // inject types based on metadata, if applicable
    this.registerTypes((0, _known.getMetadataTypes)(metadata.version));
    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)

    if (metaExtrinsic.version.gtn(0)) {
      this._extrinsicType = metaExtrinsic.version.toNumber();
    } else if (!this._options.source) {
      // detect the extrinsic version in-use based on the last block
      const {
        block: {
          extrinsics: [firstTx]
        }
      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values

      this._extrinsicType = firstTx ? firstTx.type : _Extrinsic.LATEST_EXTRINSIC_VERSION;
    }

    this._rx.extrinsicType = this._extrinsicType;
    this._rx.genesisHash = this._genesisHash;
    this._rx.runtimeVersion = this._runtimeVersion;
    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx

    this._rx.derive = this.decorateDeriveRx(this.rxDecorateMethod);
    this._derive = this.decorateDerive(this.decorateMethod);
    return true;
  }

}

exports.default = Init;

var _healthTimer = (0, _classPrivateFieldLooseKey2.default)("healthTimer");

var _updateSub = (0, _classPrivateFieldLooseKey2.default)("updateSub");

var _onProviderConnect = (0, _classPrivateFieldLooseKey2.default)("onProviderConnect");

var _onProviderDisconnect = (0, _classPrivateFieldLooseKey2.default)("onProviderDisconnect");

var _onProviderError = (0, _classPrivateFieldLooseKey2.default)("onProviderError");