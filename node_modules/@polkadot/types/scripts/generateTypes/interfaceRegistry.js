"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateInterfaceRegistry = generateInterfaceRegistry;
exports.default = generateDefaultInterfaceRegistry;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fs = _interopRequireDefault(require("fs"));

var _Raw = _interopRequireDefault(require("../../codec/Raw"));

var defaultDefinitions = _interopRequireWildcard(require("../../interfaces/definitions"));

var defaultPrimitives = _interopRequireWildcard(require("../../primitive"));

var _util = require("../util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const primitiveClasses = _objectSpread({}, defaultPrimitives, {
  Raw: _Raw.default
});

function generateInterfaceRegistry(importDefinitions, output) {
  console.log("Writing ".concat(output));
  Object.entries(importDefinitions).reduce((acc, def) => Object.assign(acc, def), {});
  const imports = (0, _util.createImports)(importDefinitions);
  const definitions = imports.definitions;
  const primitives = Object.keys(primitiveClasses).filter(name => !!name.indexOf('Generic')).reduce((accumulator, primitiveName) => {
    (0, _util.setImports)(definitions, imports, [primitiveName]);
    return [accumulator, (0, _util.getDerivedTypes)(definitions, primitiveName, primitiveName, imports).map((0, _util.indent)(2)).join('\n')].join('\n');
  }, ''); // eslint-disable-next-line @typescript-eslint/no-unused-vars

  const srml = Object.entries(definitions).reduce((accumulator, _ref) => {
    let [_defName, {
      types
    }] = _ref;
    (0, _util.setImports)(definitions, imports, Object.keys(types));
    return [accumulator, ...Object.keys(types).map(type => (0, _util.getDerivedTypes)(definitions, type, types[type], imports).map((0, _util.indent)(2)).join('\n'))].join('\n');
  }, '');
  const header = (0, _util.createImportCode)(_util.HEADER, [{
    file: '@polkadot/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@polkadot/types/primitive',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "".concat(imports.moduleToPackage[moduleName], "/").concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  }))]);
  const interfaceStart = 'export interface InterfaceRegistry {';
  const interfaceEnd = '\n}';

  _fs.default.writeFileSync(output, header.concat(interfaceStart).concat(primitives).concat(srml).concat(interfaceEnd).concat(_util.FOOTER), {
    flag: 'w'
  });
} // Generate `packages/types/src/interfaceRegistry.ts`, the registry of all interfaces


function generateDefaultInterfaceRegistry() {
  generateInterfaceRegistry({
    '@polkadot/types/interfaces': defaultDefinitions
  }, 'packages/types/src/interfaceRegistry.ts');
}