"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateQuery;

var defaultDefinitions = _interopRequireWildcard(require("../../interfaces/definitions"));

var _fs = _interopRequireDefault(require("fs"));

var _static = _interopRequireDefault(require("@polkadot/metadata/Metadata/static"));

var _util = require("@polkadot/util");

var _ = require("../..");

var _codec = require("../../codec");

var _util2 = require("../util");

// Copyright 2017-2020 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
// If the StorageEntry returns T, output `Option<T>` if the modifier is optional
function addModifier(storageEntry, returnType) {
  if (storageEntry.modifier.isOptional) {
    return "Option<".concat(returnType, ">");
  }

  return returnType;
} // From a storage entry metadata, we return [args, returnType]


function entrySignature(definitions, registry, storageEntry, imports) {
  if (storageEntry.type.isPlain) {
    (0, _util2.setImports)(definitions, imports, [storageEntry.type.asPlain.toString()]);
    return ['', (0, _util2.formatType)(definitions, addModifier(storageEntry, storageEntry.type.asPlain.toString()), imports)];
  } else if (storageEntry.type.isMap) {
    // Find similar types of the `key` type
    const similarTypes = (0, _util2.getSimilarTypes)(definitions, registry, storageEntry.type.asMap.key.toString(), imports);
    (0, _util2.setImports)(definitions, imports, [...similarTypes, storageEntry.type.asMap.value.toString()]);
    return ["arg: ".concat(similarTypes.map(type => (0, _util2.formatType)(definitions, type, imports)).join(' | ')), (0, _util2.formatType)(definitions, addModifier(storageEntry, storageEntry.type.asMap.value.toString()), imports)];
  } else if (storageEntry.type.isDoubleMap) {
    // Find similartypes of `key1` and `key2` types
    const similarTypes1 = (0, _util2.getSimilarTypes)(definitions, registry, storageEntry.type.asDoubleMap.key1.toString(), imports);
    const similarTypes2 = (0, _util2.getSimilarTypes)(definitions, registry, storageEntry.type.asDoubleMap.key2.toString(), imports);
    (0, _util2.setImports)(definitions, imports, [...similarTypes1, ...similarTypes2, storageEntry.type.asDoubleMap.value.toString()]);
    const key1Types = similarTypes1.map(type => (0, _util2.formatType)(definitions, type, imports)).join(' | ');
    const key2Types = similarTypes2.map(type => (0, _util2.formatType)(definitions, type, imports)).join(' | ');
    return ["key1: ".concat(key1Types, ", key2: ").concat(key2Types), (0, _util2.formatType)(definitions, addModifier(storageEntry, storageEntry.type.asDoubleMap.value.toString()), imports)];
  }

  throw new Error("entryArgs: Cannot parse args of entry ".concat(storageEntry.name));
} // Generate types for one storage entry in a module


function generateEntry(definitions, registry, storageEntry, imports) {
  const [args, returnType] = entrySignature(definitions, registry, storageEntry, imports);
  return ["".concat((0, _util.stringLowerFirst)(storageEntry.name.toString()), ": StorageEntryExact<ApiType, (").concat(args, ") => Observable<").concat(returnType, ">> & QueryableStorageEntry<ApiType>;")];
} // Generate types for one module


function generateModule(definitions, registry, modul, imports) {
  if (modul.storage.isNone) {
    return [];
  }

  return [(0, _util2.indent)(4)("".concat((0, _util.stringLowerFirst)(modul.name.toString()), ": {"))].concat((0, _util2.indent)(6)('[index: string]: QueryableStorageEntry<ApiType>;')).concat(modul.storage.unwrap().items.reduce((acc, storageEntry) => {
    return acc.concat(generateEntry(definitions, registry, storageEntry, imports).map((0, _util2.indent)(6)));
  }, []).join('\n')).concat([(0, _util2.indent)(4)('};')]);
} // Generate `packages/api/src/query.types.ts` for a particular
// metadata


function generateForMeta(definitions, registry, meta) {
  console.log('Writing packages/api/src/query.types.ts');
  const imports = (0, _util2.createImports)({
    '@polkadot/types/interfaces': definitions
  }); // Will hold all needed imports

  const body = meta.asLatest.modules.reduce((acc, modul) => {
    const storageEntries = generateModule(definitions, registry, modul, imports);
    return acc.concat(storageEntries);
  }, []);
  const header = (0, _util2.createImportCode)(_util2.HEADER, [{
    file: 'rxjs',
    types: ['Observable']
  }, {
    file: '@polkadot/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@polkadot/types',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "@polkadot/types/interfaces/".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  })), {
    file: '@polkadot/types/types',
    types: Object.keys(imports.typesTypes)
  }]);
  const interfaceStart = ["declare module './types' {", (0, _util2.indent)(2)('export interface QueryableStorageExact<ApiType> {\n')].join('\n');
  const interfaceEnd = "\n".concat((0, _util2.indent)(2)('}'), "\n}");

  _fs.default.writeFileSync('packages/api/src/query.types.ts', header.concat(interfaceStart).concat(body.join('\n')).concat(interfaceEnd).concat(_util2.FOOTER), {
    flag: 'w'
  });
} // Call `generateForMeta()` with current static metadata


function generateQuery() {
  const registry = new _codec.TypeRegistry();
  return generateForMeta(defaultDefinitions, registry, new _.Metadata(registry, _static.default));
}