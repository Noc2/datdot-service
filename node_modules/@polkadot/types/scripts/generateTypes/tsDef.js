"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetter = createGetter;
exports.generateTsDef = generateTsDef;
exports.default = generateTsDefDefault;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _types = require("../../codec/types");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _util = require("@polkadot/util");

var _create = require("../../codec/create");

var defaultDefinitions = _interopRequireWildcard(require("../../interfaces/definitions"));

var _util2 = require("../util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// helper to generate a `readonly <Name>: <Type>;` getter
function createGetter(definitions) {
  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let type = arguments.length > 2 ? arguments[2] : undefined;
  let imports = arguments.length > 3 ? arguments[3] : undefined;
  let doc = arguments.length > 4 ? arguments[4] : undefined;
  (0, _util2.setImports)(definitions, imports, [type]);
  return "  /** ".concat(doc || type, " */\n  readonly ").concat(name, ": ").concat(type, ";\n");
} // eslint-disable-next-line @typescript-eslint/no-unused-vars


function errorUnhandled(definitions, def, imports) {
  throw new Error("Generate: ".concat(name, ": Unhandled type ").concat(_types.TypeDefInfo[def.info]));
}

function tsExport(definitions, def, imports) {
  return (0, _util2.exportInterface)(def.name, (0, _util2.formatType)(definitions, def, imports));
}

const tsBTreeMap = tsExport;
const tsCompact = tsExport;
const tsOption = tsExport;
const tsPlain = tsExport;
const tsTuple = tsExport;

function tsEnum(definitions, _ref, imports) {
  let {
    name: enumName,
    sub
  } = _ref;
  (0, _util2.setImports)(definitions, imports, ['Enum']);
  const keys = sub.map((_ref2, index) => {
    let {
      info,
      name = '',
      type
    } = _ref2;
    const getter = (0, _util.stringUpperFirst)((0, _util.stringCamelCase)(name.replace(' ', '_')));
    const [enumType, asGetter] = type === 'Null' ? ['', ''] : ["(".concat(type, ")"), createGetter(definitions, "as".concat(getter), type, imports)];
    const isGetter = createGetter(definitions, "is".concat(getter), 'boolean', imports, "".concat(index, ":: ").concat(name).concat(enumType));

    switch (info) {
      case _types.TypeDefInfo.Plain:
      case _types.TypeDefInfo.Vec:
        return "".concat(isGetter).concat(asGetter);

      default:
        throw new Error("Enum: ".concat(enumName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
    }
  });
  return (0, _util2.exportInterface)(enumName, 'Enum', keys.join(''));
}

function tsResultGetter(definitions) {
  let resultName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let getter = arguments.length > 2 ? arguments[2] : undefined;
  let {
    info,
    name = '',
    type
  } = arguments.length > 3 ? arguments[3] : undefined;
  let imports = arguments.length > 4 ? arguments[4] : undefined;
  const [resultType, asGetter] = type === 'Null' ? ['', ''] : ["(".concat(type, ")"), createGetter(definitions, "as".concat(getter), type, imports)];
  const isGetter = createGetter(definitions, "is".concat(getter), 'boolean', imports, "".concat(getter, ":: ").concat(name).concat(resultType));

  switch (info) {
    case _types.TypeDefInfo.Plain:
    case _types.TypeDefInfo.Vec:
      return "".concat(isGetter).concat(asGetter);

    default:
      throw new Error("Result: ".concat(resultName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
  }
}

function tsResult(definitions, def, imports) {
  const [okDef, errorDef] = def.sub;
  const inner = [tsResultGetter(definitions, def.name, 'Error', errorDef, imports), tsResultGetter(definitions, def.name, 'Ok', okDef, imports)].join('');
  (0, _util2.setImports)(definitions, imports, [def.type]);
  return (0, _util2.exportInterface)(def.name, (0, _util2.formatType)(definitions, def, imports), inner);
}

function tsSet(definitions, _ref3, imports) {
  let {
    name: setName,
    sub
  } = _ref3;
  (0, _util2.setImports)(definitions, imports, ['Set']);
  const types = sub.map((_ref4) => {
    let {
      name
    } = _ref4;
    return createGetter(definitions, "is".concat(name), 'boolean', imports);
  });
  return (0, _util2.exportInterface)(setName, 'Set', types.join(''));
}

function tsStruct(definitions, _ref5, imports) {
  let {
    name: structName,
    sub
  } = _ref5;
  (0, _util2.setImports)(definitions, imports, ['Struct']);
  const keys = sub.map(typedef => {
    const returnType = (0, _util2.formatType)(definitions, typedef, imports);
    return createGetter(definitions, typedef.name, returnType, imports);
  });
  return (0, _util2.exportInterface)(structName, 'Struct', keys.join(''));
}

function tsVec(definitions, def, imports) {
  const type = def.info === _types.TypeDefInfo.VecFixed ? def.ext.type : def.sub.type; // FIXME This should be a VecFixed
  // FIXME Technically Vec has length prefix, so for others this is not 100%

  if (def.info === _types.TypeDefInfo.VecFixed && type === 'u8') {
    (0, _util2.setImports)(definitions, imports, ['Codec']);
    return (0, _util2.exportType)(def.name, 'Uint8Array, Codec');
  }

  return (0, _util2.exportInterface)(def.name, (0, _util2.formatType)(definitions, def, imports));
}

function generateInterfaces(definitions, _ref6, imports) {
  let {
    types
  } = _ref6;
  // handlers are defined externally to use - this means that when we do a
  // `generators[typedef.info](...)` TS will show any unhandled types. Rather
  // we are being explicit in having no handlers where we do not support (yet)
  const generators = {
    [_types.TypeDefInfo.BTreeMap]: tsBTreeMap,
    [_types.TypeDefInfo.Compact]: tsCompact,
    [_types.TypeDefInfo.Enum]: tsEnum,
    [_types.TypeDefInfo.Linkage]: errorUnhandled,
    [_types.TypeDefInfo.Null]: errorUnhandled,
    [_types.TypeDefInfo.Option]: tsOption,
    [_types.TypeDefInfo.Plain]: tsPlain,
    [_types.TypeDefInfo.Result]: tsResult,
    [_types.TypeDefInfo.Set]: tsSet,
    [_types.TypeDefInfo.Struct]: tsStruct,
    [_types.TypeDefInfo.Tuple]: tsTuple,
    [_types.TypeDefInfo.Vec]: tsVec,
    [_types.TypeDefInfo.VecFixed]: tsVec
  };
  return Object.entries(types).map((_ref7) => {
    let [name, type] = _ref7;
    const def = (0, _create.getTypeDef)((0, _util.isString)(type) ? type.toString() : JSON.stringify(type), {
      name
    });
    return [name, generators[def.info](definitions, def, imports)];
  });
}

function generateTsDefFor(importDefinitions, defName, _ref8, outputDir) {
  let {
    types
  } = _ref8;

  const imports = _objectSpread({}, (0, _util2.createImports)(importDefinitions, {
    types
  }), {
    interfaces: []
  });

  const definitions = imports.definitions;
  const interfaces = generateInterfaces(definitions, {
    types
  }, imports);
  const sortedDefs = interfaces.sort((a, b) => a[0].localeCompare(b[0])).map((_ref9) => {
    let [, definition] = _ref9;
    return definition;
  }).join('\n\n');
  const header = (0, _util2.createImportCode)(_util2.HEADER, [{
    file: '@polkadot/types/types',
    types: Object.keys(imports.typesTypes)
  }, {
    file: '@polkadot/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@polkadot/types/primitive',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "".concat(imports.moduleToPackage[moduleName], "/").concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  }))]);
  Object.entries(imports.localTypes).forEach((_ref10) => {
    let [moduleName, typeMap] = _ref10;
    const types = Object.keys(typeMap).sort();

    if (types.length) {
      console.log("\timport { ".concat(types.join(', '), " } from '../").concat(moduleName, "'"));
    }
  });

  _fs.default.writeFileSync(_path.default.join(outputDir, defName, 'types.ts'), header.concat(sortedDefs).concat(_util2.FOOTER), {
    flag: 'w'
  });

  _fs.default.writeFileSync(_path.default.join(outputDir, defName, 'index.ts'), _util2.HEADER.concat('export * from \'./types\';').concat(_util2.FOOTER), {
    flag: 'w'
  });
}

function generateTsDef(importDefinitions, outputDir, generatingPackage) {
  const definitions = importDefinitions[generatingPackage];
  Object.entries(definitions).forEach((_ref11) => {
    let [defName, obj] = _ref11;
    console.log("Extracting interfaces for ".concat(defName));
    generateTsDefFor(importDefinitions, defName, obj, outputDir);
  });
  console.log("Writing ".concat(outputDir));

  _fs.default.writeFileSync(_path.default.join(outputDir, 'types.ts'), _util2.HEADER.concat(Object.keys(definitions).map(moduleName => "export * from './".concat(moduleName, "/types';")).join('\n')).concat(_util2.FOOTER), {
    flag: 'w'
  });

  _fs.default.writeFileSync(_path.default.join(outputDir, 'index.ts'), _util2.HEADER.concat('export * from \'./types\';').concat(_util2.FOOTER), {
    flag: 'w'
  });
}

function generateTsDefDefault() {
  generateTsDef({
    '@polkadot/types/interfaces': defaultDefinitions
  }, 'packages/types/src/interfaces', '@polkadot/types/interfaces');
}