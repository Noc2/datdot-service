"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDerivedTypes = getDerivedTypes;
exports.getSimilarTypes = getSimilarTypes;

var _types = require("../../codec/types");

var _class = require("./class");

var _create = require("../../codec/create");

var _AbstractInt = _interopRequireDefault(require("../../codec/AbstractInt"));

var _Vec = _interopRequireDefault(require("../../codec/Vec"));

var _formatting = require("./formatting");

var _imports = require("./imports");

var primitiveClasses = _interopRequireWildcard(require("../../primitive"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
// From `T`, generate `Compact<T>, Option<T>, Vec<T>`
function getDerivedTypes(definitions, type, primitiveName, imports) {
  // `primitiveName` represents the actual primitive type our type is mapped to
  const isCompact = (0, _class.isCompactEncodable)(primitiveClasses[primitiveName]);
  const def = (0, _create.getTypeDef)(type);
  (0, _imports.setImports)(definitions, imports, ['Option', 'Vec', isCompact ? 'Compact' : '']);
  const types = [{
    info: _types.TypeDefInfo.Option,
    type,
    sub: def
  }, {
    info: _types.TypeDefInfo.Vec,
    type,
    sub: def
  }];

  if (isCompact) {
    types.unshift({
      info: _types.TypeDefInfo.Compact,
      type,
      sub: def
    });
  }

  const result = types.map(t => (0, _formatting.formatType)(definitions, t, imports)).map(t => "'".concat(t, "': ").concat(t, ";"));
  result.unshift("".concat(type, ": ").concat(type, ";"));
  return result;
} // Make types a little bit more flexible
// - if param instanceof AbstractInt, then param: u64 | Uint8array | string | number
// etc


function getSimilarTypes(definitions, registry, type, imports) {
  const possibleTypes = [type];

  if (type === 'Extrinsic') {
    (0, _imports.setImports)(definitions, imports, ['IExtrinsic']);
    return ['IExtrinsic'];
  }

  if ((0, _class.isChildClass)(_Vec.default, (0, _create.ClassOfUnsafe)(registry, type))) {
    return ["(".concat(getSimilarTypes(definitions, registry, (0, _create.getTypeDef)(type).sub.type, imports).join(' | '), ")[]")];
  } // FIXME This is a hack, it's hard to correctly type StorageKeys in the
  // current state


  if (type === 'StorageKey') {
    return ['any'];
  } // Cannot get isChildClass of abstract class, but it works


  if ((0, _class.isChildClass)(_AbstractInt.default, (0, _create.ClassOfUnsafe)(registry, type))) {
    possibleTypes.push('Uint8Array', 'number', 'string');
  } else if ((0, _class.isChildClass)(Uint8Array, (0, _create.ClassOfUnsafe)(registry, type))) {
    possibleTypes.push('Uint8Array', 'string');
  } else if ((0, _class.isChildClass)(String, (0, _create.ClassOfUnsafe)(registry, type))) {
    possibleTypes.push('string');
  }

  return possibleTypes;
}